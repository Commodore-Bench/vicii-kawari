# Extra Features

In addition to being compatible with a genuine VICII, VICII-Kawari
adds a number of new features for C64 and 8-bit hobbyests to experiment with.

## Extra Registers

Extra registers are enabled through the activation port (0xd03f)
by poking it with the PETSCII bytes "VIC2".  This prevents existing
software from unintentionally triggering extra registers.

### BASIC
    POKE 53311,ASC("V")
    POKE 53311,ASC("I")
    POKE 53311,ASC("C")
    POKE 53311,ASC("2")

### 6510 ASSEMBLY
    LDA #86
    STA $d03f
    LDA #73
    STA $d03f
    LDA #67
    STA $d03f
    LDA #50
    STA $d03f

Once activated, registers 0xd02f - 0xd03f become available and
may be used to access VICII-Kawari extra features. Extra regsters
can be deactivated again by setting bit 8 of 0xd03f to 1.

### Extra Registers Table

REG    | Name | Description
-------|------|-------------
0xd02f |      | Reserved
0xd030 |      | Reserved
0xd031 |      | Reserved
0xd032 |      | Reserved
0xd033 |      | Reserved
0xd034 |      | Reserved
0xd035 | VIDEO_MEM_1_IDX | Video Memory Index Port A (RAM only)
0xd036 | VIDEO_MEM_2_IDX | Video Memory Index Port B (RAM only)
0xd037 | VIDEO_MODE1 | See below
0xd038 | VIDEO_MODE2 | See below
0xd039 | VIDEO_MEM_1_LO | Video Memory Addr Lo Port A
0xd03a | VIDEO_MEM_1_HI | Video Memory Addr Hi Port A
0xd03b | VIDEO_MEM_1_VAL | Video Memory Read/Write Value Port A
0xd03c | VIDEO_MEM_2_LO | Video Memory Addr Lo Port B
0xd03d | VIDEO_MEM_2_HI | Video Memory Addr Hi Port B
0xd03e | VIDEO_MEM_2_VAL | Video Memory Read/Write Value Port B
0xd03f | VIDEO_MEM_FLAGS | Video Memory Op Flags (see below)

## Video Memory

VICII-Kawari adds 32k of video memory to the C64. This memory can be directly
accessed by VICII-Kawari for new graphics modes.  The registers 0xd039-0xd03f
are used to read/write from/to video memory. (This space can also be used to
store code but it would have to be copied back to main memory to be executed
by the CPU.)

VIDEO_MEM_FLAGS | Description
----------------|-------------
BIT 1,2  | PORT 1 FUNCTION <br>0=NONE<br>1=AUTO INC<br>2=AUTO DEC<br>3=COPYSRC/FILL
BIT 3,4  | PORT 2 FUNCTION <br>0=NONE<br>1=AUTO INC<br>2=AUTO DEC<br>3=COPYDST/FILLVAL
BIT 5    | Persist busy status flag (see below)
BIT 6    | Extra 256 registers overlay at 0x0000 Enable/Disable
BIT 7    | Persist Flag (see below) Changes to some registers will persist between reboots)
BIT 8    | Deactivate Extra Registers

When BIT 7 is 1, changes to some registers (like color palette, composite luma, phase, amplitude, etc) will be persisted to the MCU's EEPROM flashram and restored on reboot. Each register change must be written to the MCU's EEPROM so the MCU may not be able to keep up with many register changes back to back. To avoid lost changes, the 6502 should check BIT 5 and make sure it is 0 before attempting to set the next register. For boards that do not support persistence, BIT 7 has no function and BIT 5 is always 0.  If BIT 7 is not enabled, BIT 5 can be ignored.

VIDEO_MODE1 | Description
------------|------------
BIT 1-3     | CHAR_PIXEL_BASE
BIT 4       | PALETTE SELECT
BIT 5       | HIRES ENABLE
BIT 6-7     | HIRES MODE (0=TEXT, 1=640x200, 2=320x200, 3=640x200)
BIT 8       | UNUSED

VIDEO_MODE2 | Description
------------|------------
BIT 1-4     | MATRIX_BASE
BIT 4-8     | COLOR_BASE

## Color Memory
For the 80 column text mode, each byte stores color information as well as display attributes. 

BIT        | Description
-----------|-------------
0-3        | 16 color index
4          | blink (every 32 frames)
5          | underscore
6          | reverse video
7          | alt char set

## Hires Enable
This bit must be 1 for any of the hiresolution modes to be visible.  When enabled, badlines normally generated by the 40 column mode are disabled (as though the DEN bit is set to 0).

## Hires Mode
These bit controls the hires video mode.

HIRES MODE | Description
-----------|-------------
0          | 80 Column Text 16 Colors (4K CharDef, 2K Matrix, 2K Color)
1          | 640x200 Bitmap 16 Colors (16K Bitmap, 2K Color)
2          | 320x200 Bitmap 16 Color 2 Planes (32K Bitmap)
3          | 640x200 Bitmap 4 Color 2 Planes (32K Bitmap)

### Writing to video memory from main DRAM using auto increment
    LDA <ADDR
    STA VIDEO_MEM_A_HI
    LDA >ADDR
    STA VIDEO_MEM_A_LO
    LDA #1               ; Auto increment port 1
    STA VIDEO_MEM_FLAGS
    LDA #$55
    STA VIDEO_MEM_A_VAL  ; write $55 to video mem ADDR

    Suquential writes will auto increment the address:

    LDA #$56
    STA VIDEO_MEM_A_VAL  ; write $56 to ADDR+1
    LDA #$57
    STA VIDEO_MEM_A_VAL  ; write $57 to ADDR+2
    (...etc)

    * video mem hi/lo pairs will wrap as expected

### Reading from video memory into main DRAM using auto increment
    LDA <ADDR
    STA VIDEO_MEM_A_HI
    LDA >ADDR
    STA VIDEO_MEM_A_LO
    LDA #1               ; Auto increment port 1
    STA VIDEO_MEM_FLAGS
    LDA VIDEO_MEM_A_VAL  ; read the value

    Sequential reads will auto increment the address:

    LDA VIDEO_MEM_A_VAL ; read from ADDR+1
    LDA VIDEO_MEM_A_VAL ; read from ADDR+2
    (...etc)

    * video mem hi/lo pairs will wrap as expected

### Performing a move within video memory

Here is an example of moving memory within video RAM using the CPU.
(A much more efficient way using block copy is shown below).

    LDA <SRC_ADDR
    STA VIDEO_MEM_A_HI
    LDA >SRC_ADDR
    STA VIDEO_MEM_A_LO

    LDA <DEST_ADDR
    STA VIDEO_MEM_B_HI
    LDA >DEST_ADDR
    STA VIDEO_MEM_B_LO

    LDA #5               ; Auto increment port 1 and 2
    STA VIDEO_MEM_FLAGS

    LDA VIDEO_MEM_A_VAL  ; read from src
    STA VIDEO_MEM_B_VAL  ; write to dest

    Sequential read/writes will auto increment/decrement the address as above.

## Block Copy

You can perform high speed block copy operations by setting the vmem
port 1 and 2 functions to COPYSRC/FILL and COPYDST/FILLVAL respectively.
NOTE: Both port 1 and 2 must be configured for COPY/FILL function.

VIDEO_MEM_1_LO | Dest Lo Byte
VIDEO_MEM_1_HI | Dest Hi Byte
VIDEO_MEM_2_LO | Src Lo Byte
VIDEO_MEM_2_HI | Src Hi Byte
VIDEO_MEM_1_IDX | Num Bytes Lo
VIDEO_MEM_2_IDX | Num Bytes Hi
VIDEO_MEM_1_VAL | Perform Copy, 1=copy start to end, 2=copy end to start
VIDEO_MEM_2_VAL | Unused

### Copy Example

    LDA <SRC_ADDR
    STA VIDEO_MEM_A_HI
    LDA >SRC_ADDR
    STA VIDEO_MEM_A_LO

    LDA <DEST_ADDR
    STA VIDEO_MEM_B_HI
    LDA >DEST_ADDR
    STA VIDEO_MEM_B_LO

    LDA #15               ; Port 1 copy src, Port 2 copy dest
    STA VIDEO_MEM_FLAGS

    LDA #00
    STA VIDEO_MEM_1_IDX
    LDA #02
    STA VIDEO_MEM_2_IDX   ; 512 bytes

    LDA #1
    STA VIDEO_MEM_1_VAL   ; Perform copy (start to end)

* Copy is finished when VIDEO_MEM_1_IDX == 0 && VIDEO_MEM_2_IDX == 0
* These values do not change while copy is performed so just checking
  one value that started as not 0 for 0 is sufficient to indicate done.
* 8 bytes are moved each 6510 cycle.
* Max copy is 65535 bytes

## Block Fill

You can perform high speed block fill operations by setting the vmem
port 1 and 2 functions to COPYSRC/FILL and COPYDST/FILLVAL respectively.

### Fill

VIDEO_MEM_1_LO | Start Lo Byte
VIDEO_MEM_1_HI | Start Hi Byte
VIDEO_MEM_1_IDX | Num Bytes Lo
VIDEO_MEM_2_IDX | Num Bytes Hi
VIDEO_MEM_2_LO  | Byte for fill
VIDEO_MEM_2_HI  | Unused
VIDEO_MEM_1_VAL | 4 = Perform fill with byte stored in VIDEO_MEM_2_VAL
VIDEO_MEM_2_VAL | Unused

### Fill Example

    LDA <DST_ADDR
    STA VIDEO_MEM_A_HI
    LDA >DST_ADDR
    STA VIDEO_MEM_A_LO

    LDA #15               ; Port 1 fill dst, Port 2 fill val
    STA VIDEO_MEM_FLAGS

    LDA #00
    STA VIDEO_MEM_1_IDX
    LDA #02
    STA VIDEO_MEM_2_IDX   ; 512 bytes

    LDA #ff               ; Byte for fill
    STA VIDEO_MEM_2_LO

    LDA #4
    STA VIDEO_MEM_1_VAL   ; Perform fill

* Fill is finished when VIDEO_MEM_1_IDX == 0 && VIDEO_MEM_2_IDX == 0
* These values do not change while copy is performed so just checking
  one value that started as not 0 for 0 is sufficient to indicate done.
* 32 bytes are filled each 6510 cycle.
* Max fill is 65535 bytes

### Using video mem pointers with an index

Sometimes, it may be more convenient to use an index when porting code to use VICII-Kawari extended video memory.  This is useful if replacing indirect indexed addressing.

For example, the code:

    LDY #20
    LDA #00
    STA $fc
    LDA #04
    STA $fd
    LDA ($fc),y

Can be replaced with:

    LDY #20
    LDA #00
    STA VIDEO_MEM_A_LO
    LDA #04
    STA VIDEO_MEM_A_HI
    STY VIDEO_MEM_A_IDX
    LDA VIDEO_MEM_A_VAL

NOTE: VIDEO_MEM_?_IDX only applies to RAM access, not the extended register
      overlay area between 0x00 - 0xff described below.

### Extra Registers Overlay

When BIT 6 of the VIDEO_MEM_FLAGS register is set, the first 256 bytes
of video RAM is mapped to extra registers for special VICII-Kawari
functions.

### Color Registers

VICII-Kawari has a configurable color palette. The 16 colors can be selected
from a palette of 262144 colors by specifying three 6-bit RGB values. (The
upper 2 bits in each byte are ignored).  The palette is also double buffered
to allow changing all colors instantaneously with the palette select bit in
register VIDEO_MODE1. Palette 0 is located at 0x0000. Palette 1 is located at
0x0040.

Location | Name | Description | Capability Requirement
---------|------|-------------|-----------------------
0x0000 - 0x003f | PAL0_RGB | 4x16 array of RGBx for palette 0 (4th byte unused) | CONFIG_RGB
0x0040 - 0x007f | PAL1_RGB | 4x16 array of RGBx for palette 1 (4th byte unused) | CONFIG_RGB
0x0080 | BLACK_LEVEL | Composite black level (0-63) | CONFIG_COMPOSITE
0x0081 | BURST_AMPLITUDE | Composite color burst amplitude (1-15, 0 = no color burst) | CONFIG_COMPOSITE
0x0082 | CHIP_MODEL | Chip Model Select (0=6567R8, 1=6569, 2=6567R56A) | NONE
0x0083 | VERSION | Version (high nibble major, low nibble minor) - Read Only | NONE
0x0084 | DISPLAY_FLAGS | See below | NONE
0x0085 | CURSOR_LO | Hires Cursor lo byte | HIRES_MODES
0x0086 | CURSOR_HI | Hires Cursor hi byte | HIRES_MODES
0x0087 | CAP_LO    | Capability Bits lo byte (Read Only)| NONE
0x0088 | CAP_HI    | Capability Bits hi byte (Read Only)| NONE
0x0089 - 0x008f | Reserved | Reserved | NONE
0x0090 - 0x009f | VARIANT_NAME | Variant Name | NONE
0x00a0 - 0x00af | LUMA_LEVELS | Composite luma levels for colors (0-63) | CONFIG_COMPOSITE
0x00b0 - 0x00bf | PHASE_VALUES | Composite phase values for colors (0-255 representing 0-359 degrees) | CONFIG_COMPOSITE
0x00c0 - 0x00cf | AMPL_VALUES | Composite amplitude values for colors (1-15, 0 = no modulation) | CONFIG_COMPOSITE
0x00d0 | FPORCH | HDMI/VGA 1X NTSC H front porch (15 khz mode) | CONFIG_RGB
0x00d1 | SPULSE | HDMI/VGA 1X NTSC H sync pulse (15 khz mode) | CONFIG_RGB
0x00d2 | BPORCH | HDMI/VGA 1X NTSC H back porch (15 khz mode) | CONFIG_RGB
0x00d3 | FPORCH | HDMI/VGA 1Y NTSC V front porch (15 khz mode) | CONFIG_RGB
0x00d4 | SPULSE | HDMI/VGA 1Y NTSC V sync pulse (15 khz mode) | CONFIG_RGB
0x00d5 | BPORCH | HDMI/VGA 1Y NTSC V back porch (15 khz mode) | CONFIG_RGB
0x00d6 | FPORCH | HDMI/VGA 2X NTSC H front porch (31 khz mode) | CONFIG_RGB
0x00d7 | SPULSE | HDMI/VGA 2X NTSC H sync pulse (31 khz mode) | CONFIG_RGB
0x00d8 | BPORCH | HDMI/VGA 2X NTSC H back porch (31 khz mode) | CONFIG_RGB
0x00d9 | FPORCH | HDMI/VGA 2Y NTSC V front porch (31 khz mode) | CONFIG_RGB
0x00da | SPULSE | HDMI/VGA 2Y NTSC V sync pulse (31 khz mode) | CONFIG_RGB
0x00db | BPORCH | HDMI/VGA 2Y NTSC V back porch (31 khz mode) | CONFIG_RGB
0x00dc | FPORCH | HDMI/VGA 1X PAL H front porch (15 khz mode) | CONFIG_RGB
0x00dd | SPULSE | HDMI/VGA 1X PAL H sync pulse (15 khz mode) | CONFIG_RGB
0x00de | BPORCH | HDMI/VGA 1X PAL H back porch (15 khz mode) | CONFIG_RGB
0x00df | FPORCH | HDMI/VGA 1Y PAL V front porch (15 khz mode) | CONFIG_RGB
0x00e0 | SPULSE | HDMI/VGA 1Y PAL V sync pulse (15 khz mode) | CONFIG_RGB
0x00e1 | BPORCH | HDMI/VGA 1Y PAL V back porch (15 khz mode) | CONFIG_RGB
0x00e2 | FPORCH | HDMI/VGA 2X PAL H front porch (31 khz mode) | CONFIG_RGB
0x00e3 | SPULSE | HDMI/VGA 2X PAL H sync pulse (31 khz mode) | CONFIG_RGB
0x00e4 | BPORCH | HDMI/VGA 2X PAL H back porch (31 khz mode) | CONFIG_RGB
0x00e5 | FPORCH | HDMI/VGA 2Y PAL V front porch (31 khz mode) | CONFIG_RGB
0x00e6 | SPULSE | HDMI/VGA 2Y PAL V sync pulse (31 khz mode) | CONFIG_RGB
0x00e7 | BPORCH | HDMI/VGA 2Y PAL V back porch (31 khz mode) | CONFIG_RGB
0x00d8 | CHANGE | Timing change signal - Bit 1  | CONFIG_RGB

DISPLAY_FLAGS|Function
-------------|-------
Bit 1        | Raster lines visible(1) or invisible(0)
Bit 2        | Use native y resolution rather than double (1=15khz, 0=31khz)
Bit 3        | Use native x resolution rather than double (1=native, 0=doubled)
Bit 4-8      | Reserved

* Double x resolution is required for 80 column mode or any hires mode.

CAP_LO|Function
------|--------
Bit 1 | Has analog RGB out
Bit 2 | Has digital RGB out (HDMI/DVI)
Bit 3 | Has composite out (LUMA/CHROMA)
Bit 4 | Has configurable RGB palette
Bit 5 | Has configurable Luma/Chroma/Amplitude
Bit 6 | Has configurable analog/digital RGB timing params
Bit 7 | Has configuration persistance
Bit 8 | Reserved

CAP_HI|Function
------|--------
Bit 1-9 | Reserved

### Variant Name

The extra register overlay area 0x0090 - 0xd09f is used to identify the
variant name. This is a max 16 byte null terminated PETSCII string.  All
forks should change this to something other than 'official' if they plan
on releasing a bitstream. See [FORKING.md](FORKING.md)

## Notes

The extra registers described here should remain functional across all
VICII-Kawari variants. This way, the official configuration utility will
be able to at least query the variant name and version on any variant
(as well as set palette colors, change video standard, or other common
features between variants). Users will be able to at least identify what
variant they are running even if they use the official config utility.
Also, programs can run a simple check routine that will run on all variants
and can display a user friendly message indicating the wrong variant is
installed.

# Notation

Bit   | Description | Value
------|-------------|------
Bit 1 | LSB | 1
Bit 2 |  | 2
Bit 3 |  | 4
Bit 4 |  | 8
Bit 5 |  | 16
Bit 6 |  | 32
Bit 7 |  | 64
Bit 8 | MSB | 128
